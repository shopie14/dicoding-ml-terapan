# -*- coding: utf-8 -*-
"""recommender system rating anime.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WaBKgRqDqXu7lq_fWcPK-kfeJec4gGNS
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/drive/MyDrive/Dicoding/ML Terapan/recommendation-system"

"""# Bussiness Understanding

Setiap konten streaming memiliki penontonnya masing-masing dan setiap konten memiliki ratingnya sendiri. Pemirsa memberikan peringkat bagus untuk konten tersebut jika mereka menyukainya. Tapi di mana penerapannya? Pemirsa dapat menghabiskan waktu berjam-jam menelusuri ratusan, terkadang ribuan anime, tetapi tidak pernah mendapatkan konten yang mereka sukai. Bisnis perlu memberikan saran berdasarkan kesukaan dan kebutuhan pemirsa untuk menciptakan lingkungan streaming yang lebih baik yang meningkatkan pendapatan dan meningkatkan waktu yang dihabiskan di situs web.

# Import Libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

"""# Data Understanding

Dataset ini berisi informasi data preferensi pengguna dari 73.516 pengguna pada 12.294 anime. Setiap pengguna dapat menambahkan anime ke daftar lengkapnya dan memberinya peringkat dan kumpulan data ini adalah kompilasi dari peringkat tersebut.

Sumber dataset : https://www.kaggle.com/datasets/CooperUnion/anime-recommendations-database
"""

anime = pd.read_csv('anime.csv')
rating = pd.read_csv('rating.csv')
anime.head(100)

rating.head(100)

"""anime.csv:
- anime_id : ID unik myanimelist.net yang mengidentifikasi sebuah anime.
- name : nama lengkap anime.
- genre : daftar genre yang dipisahkan koma untuk anime ini.
- type : film, TV, OVA, dll.
- episode : berapa episode dalam acara ini. (1 jika film).
- rating : rating rata-rata dari 10 untuk anime ini.
- member : jumlah anggota komunitas yang tergabung dalam "grup" anime ini.
---
rating.csv
- user_id : id pengguna yang dibuat secara acak dan tidak dapat diidentifikasi. - anime_id : anime yang diberi rating oleh pengguna ini.
- rating : peringkat dari 10 yang ditetapkan pengguna ini (-1 jika pengguna menontonnya tetapi tidak memberikan peringkat).

# Explaratory Data
"""

print(f"Dimensi Anime Dataset : {anime.shape}")
anime.head()

print(f"Information about Anime Dataset :\n")
print(anime.info())

print(f"Shape of Rating Dataset : {anime.shape}")
rating.head()

print(f"Information about Rating Dataset :\n")
print(rating.info())

print(f"Summary of The Anime Dataset :")
anime.describe()

print(f"Summary of The Rating Dataset :")
rating.describe()

print("Null Values of Anime Dataset :")
anime.isna().sum().to_frame()

print("After Dropping, Null Values of Anime Dataset :")
anime.dropna(axis = 0, inplace = True)
anime.isna().sum().to_frame()

dup_anime = anime[anime.duplicated()].shape[0]
print(f"There are {dup_anime} duplicate entries among {anime.shape[0]}")

print("Null Values of Anime Dataset :")
rating.isna().sum().to_frame()

print("Null Values of Rating Dataset :")
rating.isna().sum().to_frame()

dup_rating = rating[rating.duplicated()].shape[0]
print(f"There are {dup_rating} duplicate entries among {rating.shape[0]} entries in rating dataset.")

rating.drop_duplicates(keep='first',inplace=True)
print(f"\nAfter removing duplicate entries there are {rating.shape[0]} entries in this dataset.")

"""# Explaratory Digging Deeper"""

# Let's merge the anime and rating datasets.
fulldata = pd.merge(anime, rating, on="anime_id", suffixes= [None, "_user"])
fulldata = fulldata.rename(columns={"rating_user": "user_rating"})

print(f"Shape of The Merged Dataset : {fulldata.shape}")
print(f"\nGlimpse of The Merged Dataset :")

fulldata.head()

"""# Visualization

## Top Anime
"""

top_anime = fulldata.copy()
top_anime.drop_duplicates(subset ="name", keep = "first", inplace = True)
top_anime_temp1 = top_anime.sort_values(["members"],ascending=False)

palette = ["#1d7874","#679289"]
plt.subplots(figsize=(20,8))
p = sns.barplot(x=top_anime_temp1["name"][:14],y=top_anime_temp1["members"], palette = palette, saturation=1, edgecolor = "#1c1c1c", linewidth = 2)
p.axes.set_title("\nTop Anime Community\n", fontsize=25)
plt.ylabel("Total Member" , fontsize = 20)
plt.xlabel("\nAnime Name" , fontsize = 20)
# plt.yscale("log")
plt.xticks(rotation = 90)
for container in p.containers:
    p.bar_label(container, label_type = "center", padding = 6, size = 15, color = "black", rotation = 90,
    bbox={"boxstyle": "round", "pad": 0.6, "facecolor": "orange", "edgecolor": "black", "alpha": 1})

sns.despine(left=True, bottom=True)
plt.show()

"""Death Note memiliki rating tertinggi diikuti oleh Shingeki no Kyojin dan Sword Art Online

## Anime Category
"""

print("Anime Categories :")
top_anime_temp1["type"].value_counts().to_frame()

plt.subplots(figsize=(12, 12))

labels = "TV","OVA","Movie","Special","ONA","Music"
size = 0.5

wedges, texts, autotexts = plt.pie([len(top_anime_temp1[top_anime_temp1["type"]=="TV"]["type"]),
                                    len(top_anime_temp1[top_anime_temp1["type"]=="OVA"]["type"]),
                                    len(top_anime_temp1[top_anime_temp1["type"]=="Movie"]["type"]),
                                    len(top_anime_temp1[top_anime_temp1["type"]=="Special"]["type"]),
                                    len(top_anime_temp1[top_anime_temp1["type"]=="ONA"]["type"]),
                                    len(top_anime_temp1[top_anime_temp1["type"]=="Music"]["type"])],
                                    explode = (0,0,0,0,0,0),
                                    textprops=dict(size= 20, color= "white"),
                                    autopct="%.2f%%",
                                    pctdistance = 0.7,
                                    radius=.9,
                                    colors = palette,
                                    shadow = True,
                                    wedgeprops=dict(width = size, edgecolor = "#1c1c1c",
                                    linewidth = 4),
                                    startangle = 0)

plt.legend(wedges, labels, title="Category",loc="center left",bbox_to_anchor=(1, 0, 0.5, 1))
plt.title("\nAnime Categories Distribution",fontsize=20)
plt.show()

plt.subplots(figsize = (20,8))
p = sns.countplot(x = top_anime_temp1["type"], order = top_anime_temp1["type"].value_counts().index, palette = palette, saturation = 1, edgecolor = "#1c1c1c", linewidth = 3)
p.axes.set_title("\nAnime Categories Hub\n" ,fontsize = 25)
plt.ylabel("Total Anime" ,fontsize = 20)
plt.xlabel("\nAnime Category" ,fontsize = 20)
plt.xticks(rotation = 0)
for container in p.containers:
    p.bar_label(container,label_type = "center",padding = 10,size = 25,color = "black",rotation = 0,
    bbox={"boxstyle": "round", "pad": 0.4, "facecolor": "orange", "edgecolor": "black", "linewidth" : 3, "alpha": 1})

sns.despine(left = True, bottom = True)
plt.show()

"""- 3402 anime ditayangkan di TV yang merupakan 30,48% dari total anime
- 2111 anime ditayangkan sebagai Film yaitu 18,91% dari total anime
- 3090 anime disiarkan sebagai OVA yang merupakan 27,69% dari total anime juga lebih besar dari ONA yang mencakup 526 anime yaitu 4,71 % dari total anime.

## Anime Ratings
"""

top_anime_temp2 = top_anime.sort_values(["rating"],ascending=False)

_, axs = plt.subplots(2,1,figsize=(10,15),sharex=False,sharey=False)
plt.tight_layout(pad=6.0)

sns.histplot(top_anime_temp2["rating"],color=palette[1],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[0])
axs[0].lines[0].set_color(palette[0])
axs[0].set_title("\nAnime's Average Ratings Distribution\n",fontsize = 25)
axs[0].set_xlabel("Rating\n", fontsize = 20)
axs[0].set_ylabel("Total", fontsize = 20)

sns.histplot(fulldata["user_rating"],color=palette[0],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True)
axs[1].lines[0].set_color(palette[1])
# axs[1].set_yscale("log")
axs[1].set_title("\n\n\nUsers Anime Ratings Distribution\n",fontsize = 25)
axs[1].set_xlabel("Rating", fontsize = 20)
axs[1].set_ylabel("Total", fontsize = 20)

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 5,5 - 8,0
- Sebagian besar rating pengguna tersebar antara 6,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 8,0
- Kedua distribusi tersebut condong ke kiri
-Peringkat pengguna (-1) merupakan outlier dalam peringkat pengguna yang dapat dibuang

## Top Animes Based On Ratings
"""

plt.subplots(figsize=(20,8))
p = sns.barplot(x=top_anime_temp2["name"][:14],y=top_anime_temp2["rating"],palette=palette, saturation=1, edgecolor = "#1c1c1c", linewidth = 2)
p.axes.set_title("\nTop Animes Based On Ratings\n",fontsize = 25)
plt.ylabel("Average Rating",fontsize = 20)
plt.xlabel("\nAnime Title",fontsize = 20)
# plt.yscale("log")
plt.xticks(rotation = 90)
for container in p.containers:
    p.bar_label(container,label_type = "center",padding = 10,size = 15,color = "black",rotation = 0,
    bbox={"boxstyle": "round", "pad": 0.6, "facecolor": "orange", "edgecolor": "black", "alpha": 1})

sns.despine(left=True, bottom=True)
plt.show()

"""Mogura no Motoro menduduki mahkota untuk rating tertinggi diikuti oleh Kimi no Na wa. dan Fullmetal Alchemist: Brotherhood

## Category-wise Anime Ratings Distribution
"""

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="TV"]["rating"],color=palette[0],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[1])
axs[0].lines[0].set_color(palette[1])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : TV]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="TV"]["user_rating"],color=palette[0],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[1])
axs[1].lines[0].set_color(palette[1])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : TV]\n", fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 6,0 - 8,0
- Sebagian besar rating pengguna tersebar antara 6,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 9,0
- Kedua distribusi tersebut condong ke kiri
- Rating pengguna (-1) merupakan outlier dalam peringkat pengguna yang dapat dibuang
"""

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="OVA"]["rating"],color=palette[1],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[1])
axs[0].lines[0].set_color(palette[0])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : OVA]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="OVA"]["user_rating"],color=palette[1],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[1])
axs[1].lines[0].set_color(palette[0])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : OVA]\n",fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 5,5 - 7,5
- Sebagian besar rating pengguna tersebar antara 5,5 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 8,0
- Kedua distribusi tersebut miring ke kiri
- Peringkat pengguna (-1) adalah outlier dalam peringkat pengguna yang dapat dibuang
"""

print("Let's explore the ratings distribution of MOVIE category :\n")

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="Movie"]["rating"],color=palette[0],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[1])
axs[0].lines[0].set_color(palette[0])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : Movie]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="Movie"]["user_rating"],color=palette[0],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[1])
axs[1].lines[0].set_color(palette[0])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : Movie]\n",fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime berkisar antara 4,5 - 8,5
- Sebagian besar rating pengguna berkisar antara 5,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 9,0
- Kedua distribusi tersebut miring ke kiri
- Peringkat pengguna (-1) adalah outlier dalam peringkat pengguna yang dapat dibuang
"""

print("Let's explore the ratings distribution of SPECIAL category :\n")

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="Special"]["rating"],color=palette[0],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[1])
axs[0].lines[0].set_color(palette[0])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : Special]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="Special"]["user_rating"],color=palette[1],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[1])
axs[1].lines[0].set_color(palette[0])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : Special]\n",fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 5,5 - 8,0
- Sebagian besar rating pengguna tersebar antara 5,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 8,0
- Kedua distribusi tersebut condong ke kiri
- Peringkat pengguna (-1) adalah outlier dalam peringkat pengguna yang dapat dibuang
"""

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="ONA"]["rating"],color=palette[0],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[1])
axs[0].lines[0].set_color(palette[1])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : ONA]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="ONA"]["user_rating"],color=palette[0],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[1])
axs[1].lines[0].set_color(palette[1])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : ONA]\n",fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 4,0 - 7,0
- Sebagian besar rating pengguna tersebar antara 5,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 7,0 - 8,0
- Kedua distribusi tersebut condong ke kiri
- Peringkat pengguna (-1) adalah outlier dalam peringkat pengguna yang dapat dibuang
"""

_, axs = plt.subplots(1,2,figsize=(20,8),sharex=False,sharey=False)
plt.tight_layout(pad=4.0)

sns.histplot(top_anime_temp2[top_anime_temp2["type"]=="Music"]["rating"],color=palette[1],kde=True,ax=axs[0],bins=20,alpha=1,fill=True,edgecolor=palette[0])
axs[0].lines[0].set_color(palette[0])
axs[0].set_title("\nAnime's Average Ratings Distribution [Category : Music]\n",fontsize=20)
axs[0].set_xlabel("Rating")
axs[0].set_ylabel("Total")

sns.histplot(fulldata[fulldata["type"]=="Music"]["user_rating"],color=palette[1],kde=True,ax=axs[1],bins="auto",alpha=1,fill=True,edgecolor=palette[0])
axs[1].lines[0].set_color(palette[0])
# axs[1].set_yscale("log")
axs[1].set_title("\nUsers Anime Ratings Distribution [Category : Music]\n",fontsize=20)
axs[1].set_xlabel("Rating")
axs[1].set_ylabel("Total")

sns.despine(left=True, bottom=True)
plt.show()

"""- Sebagian besar rating Anime tersebar antara 4,0 - 7,5
- Sebagian besar rating pengguna tersebar antara 5,0 - 10,0
- Modus distribusi rating pengguna adalah sekitar 6,5 - 8,0
- Kedua distribusi tersebut miring ke kiri
- Peringkat pengguna (-1) adalah outlier dalam peringkat pengguna yang dapat dibuang

# Final Data Preprocessing
"""

data = fulldata.copy()
data["user_rating"].replace(to_replace = -1 , value = np.nan ,inplace=True)
data = data.dropna(axis = 0)
print("Null values after final pre-processing :")
data.isna().sum().to_frame().T

"""----
Ada banyak pengguna yang hanya memberikan rating satu kali, meskipun mereka telah memberi rating 5 anime, hal tersebut tidak dapat dianggap sebagai catatan berharga untuk rekomendasi.

----
Jadi, akan mempertimbangkan minimum 50 peringkat oleh pengguna sebagai nilai ambang batas. Dengan membuat tabel pivot yang terdiri dari baris sebagai judul dan kolom sebagai user id, ini akan membantu  membuat matriks renggang yang bisa sangat membantu dalam mencari kesamaan cosinus.
"""

selected_users = data["user_id"].value_counts()
data = data[data["user_id"].isin(selected_users[selected_users >= 50].index)]

data_pivot_temp = data.pivot_table(index="name",columns="user_id",values="user_rating").fillna(0)
data_pivot_temp.head()

import re
def text_cleaning(text):
    text = re.sub(r'&quot;', '', text)
    text = re.sub(r'.hack//', '', text)
    text = re.sub(r'&#039;', '', text)
    text = re.sub(r'A&#039;s', '', text)
    text = re.sub(r'I&#039;', 'I\'', text)
    text = re.sub(r'&amp;', 'and', text)

    return text

data["name"] = data["name"].apply(text_cleaning)

data_pivot = data.pivot_table(index="name",columns="user_id",values="user_rating").fillna(0)
print("After Cleaning the animes names, let's see how it looks like.")
data_pivot.head()

"""# Collaborative Recommender

Pemfilteran kolaboratif adalah teknik yang dapat menyaring item yang mungkin disukai pengguna berdasarkan reaksi dari pengguna serupa. Ia bekerja dengan mencari sekelompok besar orang dan menemukan sekelompok kecil pengguna dengan selera yang mirip dengan pengguna tertentu. Dalam proyek akan menggunakan kesamaan Cosine yang merupakan metrik yang digunakan untuk mengukur seberapa mirip suatu dokumen terlepas dari ukurannya. Secara matematis, ini mengukur kosinus sudut antara dua vektor yang diproyeksikan dalam ruang multidimensi. Kesamaan kosinus menguntungkan karena meskipun dua dokumen serupa berjauhan berdasarkan jarak Euclidean (karena ukuran dokumen), kemungkinan keduanya masih diorientasikan lebih berdekatan. Semakin kecil sudutnya, semakin tinggi kesamaan kosinusnya
"""

from scipy.sparse import csr_matrix
from sklearn.neighbors import NearestNeighbors

data_matrix = csr_matrix(data_pivot.values)

model_knn = NearestNeighbors(metric = "cosine", algorithm = "brute")
model_knn.fit(data_matrix)

query_no = np.random.choice(data_pivot.shape[0])
print(f"We will find recommendation for {query_no} no anime which is {data_pivot.index[query_no]}.")
distances, indices = model_knn.kneighbors(data_pivot.iloc[query_no,:].values.reshape(1, -1), n_neighbors = 6)

no = []
name = []
distance = []
rating = []

for i in range(0, len(distances.flatten())):
    if i == 0:
        print(f"Recommendations for {data_pivot.index[query_no]} viewers :\n")
    else:
        #  print(f"{i}: {data_pivot.index[indices.flatten()[i]]} , with distance of {distances.flatten()[i]}")
        no.append(i)
        name.append(data_pivot.index[indices.flatten()[i]])
        distance.append(distances.flatten()[i])
        rating.append(*anime[anime["name"]==data_pivot.index[indices.flatten()[i]]]["rating"].values)

dic = {"No" : no, "Anime Name" : name, "Rating" : rating}
recommendation = pd.DataFrame(data = dic)
recommendation.set_index("No", inplace = True)
recommendation.style.set_properties(**{"background-color": "#2a9d8f","color":"white","border": "1.5px  solid black"})

"""# Content Based Recommender

Pemfilteran berbasis konten merekomendasikan item berdasarkan perbandingan antara konten item dan profil pengguna. Isi setiap item direpresentasikan sebagai sekumpulan deskriptor atau istilah, biasanya kata-kata yang muncul dalam dokumen. Pemberi rekomendasi berbasis konten bekerja dengan data yang disediakan pengguna, baik secara eksplisit (memberi peringkat) atau secara implisit (mengklik tautan). Berdasarkan data tersebut, profil pengguna dibuat yang kemudian digunakan untuk memberikan saran kepada pengguna. Saat pengguna memberikan lebih banyak masukan atau mengambil tindakan berdasarkan rekomendasi, mesin menjadi semakin akurat.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

tfv = TfidfVectorizer(min_df=3, max_features=None, strip_accents="unicode", analyzer="word",
                      token_pattern=r"\w{1,}", ngram_range=(1, 3), stop_words = "english")

rec_data = fulldata.copy()
rec_data.drop_duplicates(subset ="name", keep = "first", inplace = True)
rec_data.reset_index(drop = True, inplace = True)
genres = rec_data["genre"].str.split(", | , | ,").astype(str)
tfv_matrix = tfv.fit_transform(genres)

"""Di sini kita perlu menetapkan 1 untuk anime yang direkomendasikan dan 0 untuk anime yang tidak direkomendasikan yang akan menggunakan kernel sigmoid"""

from sklearn.metrics.pairwise import sigmoid_kernel

sig = sigmoid_kernel(tfv_matrix, tfv_matrix)

rec_indices = pd.Series(rec_data.index, index = rec_data["name"]).drop_duplicates()

def give_recommendation(title, sig = sig):

    idx = rec_indices[title]

    sig_score = list(enumerate(sig[idx]))
    sig_score = sorted(sig_score, key=lambda x: x[1], reverse=True)
    sig_score = sig_score[1:11]
    anime_indices = [i[0] for i in sig_score]

    # Top 10 most similar movies
    rec_dic = {"No" : range(1,11),
               "Anime Name" : anime["name"].iloc[anime_indices].values,
               "Rating" : anime["rating"].iloc[anime_indices].values}
    dataframe = pd.DataFrame(data = rec_dic)
    dataframe.set_index("No", inplace = True)

    print(f"Recommendations for {title} viewers :\n")

    return dataframe.style.set_properties(**{"background-color": "#2a9d8f","color":"white","border": "1.5px  solid black"})

give_recommendation("Love Stage!!")

"""# Summary

> Sistem Rekomendasi dengan menggunakan collaborative recommender dan content based recommender berhasil dibuat
"""